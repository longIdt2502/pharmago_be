// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: debt_note.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createDebtNote = `-- name: CreateDebtNote :one
INSERT INTO debt_note (
    code, title, entity, money, paymented, note, type, status, company, user_created, exprise, dabt_note_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, code, title, entity, money, paymented, note, type, status, company, user_created, exprise, dabt_note_at
`

type CreateDebtNoteParams struct {
	Code        string         `json:"code"`
	Title       sql.NullString `json:"title"`
	Entity      string         `json:"entity"`
	Money       float64        `json:"money"`
	Paymented   float64        `json:"paymented"`
	Note        sql.NullString `json:"note"`
	Type        string         `json:"type"`
	Status      string         `json:"status"`
	Company     int32          `json:"company"`
	UserCreated int32          `json:"user_created"`
	Exprise     time.Time      `json:"exprise"`
	DabtNoteAt  sql.NullTime   `json:"dabt_note_at"`
}

func (q *Queries) CreateDebtNote(ctx context.Context, arg CreateDebtNoteParams) (DebtNote, error) {
	row := q.db.QueryRowContext(ctx, createDebtNote,
		arg.Code,
		arg.Title,
		arg.Entity,
		arg.Money,
		arg.Paymented,
		arg.Note,
		arg.Type,
		arg.Status,
		arg.Company,
		arg.UserCreated,
		arg.Exprise,
		arg.DabtNoteAt,
	)
	var i DebtNote
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Title,
		&i.Entity,
		&i.Money,
		&i.Paymented,
		&i.Note,
		&i.Type,
		&i.Status,
		&i.Company,
		&i.UserCreated,
		&i.Exprise,
		&i.DabtNoteAt,
	)
	return i, err
}

const createRepayment = `-- name: CreateRepayment :one
INSERT INTO debt_repayment (
    code, money, debt, user_created
) VALUES (
    $1, $2, $3, $4
) RETURNING id, code, money, created_at, debt, user_created
`

type CreateRepaymentParams struct {
	Code        string  `json:"code"`
	Money       float64 `json:"money"`
	Debt        int32   `json:"debt"`
	UserCreated int32   `json:"user_created"`
}

func (q *Queries) CreateRepayment(ctx context.Context, arg CreateRepaymentParams) (DebtRepayment, error) {
	row := q.db.QueryRowContext(ctx, createRepayment,
		arg.Code,
		arg.Money,
		arg.Debt,
		arg.UserCreated,
	)
	var i DebtRepayment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Money,
		&i.CreatedAt,
		&i.Debt,
		&i.UserCreated,
	)
	return i, err
}

const detailDebtNote = `-- name: DetailDebtNote :one
SELECT dn.id, dn.code, title, entity, money, paymented, note, dn.type, status, dn.company, dn.user_created, exprise, dabt_note_at, a.id, username, hashed_password, a.full_name, a.email, a.type, oa_id, is_verify, password_changed_at, a.created_at, role, gender, licence, dob, a.address, c.id, c.full_name, c.code, c.company, c.address, c.email, c.phone, license, birthday, c.user_created, user_updated, updated_at, c.created_at, s.id, s.code, name, deputy_name, s.phone, s.email, s.address, s.company, a.full_name AS a_name, c.full_name AS c_name, s.name AS s_name FROM debt_note dn
LEFT JOIN accounts a ON a.id = dn.user_created
LEFT JOIN customers c ON c.code = dn.entity
LEFT JOIN suplier s ON s.code = dn.entity
WHERE dn.id = $1
`

type DetailDebtNoteRow struct {
	ID                int32          `json:"id"`
	Code              string         `json:"code"`
	Title             sql.NullString `json:"title"`
	Entity            string         `json:"entity"`
	Money             float64        `json:"money"`
	Paymented         float64        `json:"paymented"`
	Note              sql.NullString `json:"note"`
	Type              string         `json:"type"`
	Status            string         `json:"status"`
	Company           int32          `json:"company"`
	UserCreated       int32          `json:"user_created"`
	Exprise           time.Time      `json:"exprise"`
	DabtNoteAt        sql.NullTime   `json:"dabt_note_at"`
	ID_2              sql.NullInt32  `json:"id_2"`
	Username          sql.NullString `json:"username"`
	HashedPassword    sql.NullString `json:"hashed_password"`
	FullName          sql.NullString `json:"full_name"`
	Email             sql.NullString `json:"email"`
	Type_2            sql.NullInt32  `json:"type_2"`
	OaID              sql.NullString `json:"oa_id"`
	IsVerify          sql.NullBool   `json:"is_verify"`
	PasswordChangedAt sql.NullTime   `json:"password_changed_at"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	Role              sql.NullInt32  `json:"role"`
	Gender            NullGender     `json:"gender"`
	Licence           sql.NullString `json:"licence"`
	Dob               sql.NullTime   `json:"dob"`
	Address           sql.NullInt32  `json:"address"`
	ID_3              sql.NullInt32  `json:"id_3"`
	FullName_2        sql.NullString `json:"full_name_2"`
	Code_2            sql.NullString `json:"code_2"`
	Company_2         sql.NullInt32  `json:"company_2"`
	Address_2         sql.NullInt32  `json:"address_2"`
	Email_2           sql.NullString `json:"email_2"`
	Phone             sql.NullString `json:"phone"`
	License           sql.NullString `json:"license"`
	Birthday          sql.NullTime   `json:"birthday"`
	UserCreated_2     sql.NullInt32  `json:"user_created_2"`
	UserUpdated       sql.NullInt32  `json:"user_updated"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	CreatedAt_2       sql.NullTime   `json:"created_at_2"`
	ID_4              sql.NullInt32  `json:"id_4"`
	Code_3            sql.NullString `json:"code_3"`
	Name              sql.NullString `json:"name"`
	DeputyName        sql.NullString `json:"deputy_name"`
	Phone_2           sql.NullString `json:"phone_2"`
	Email_3           sql.NullString `json:"email_3"`
	Address_3         sql.NullInt32  `json:"address_3"`
	Company_3         sql.NullInt32  `json:"company_3"`
	AName             sql.NullString `json:"a_name"`
	CName             sql.NullString `json:"c_name"`
	SName             sql.NullString `json:"s_name"`
}

func (q *Queries) DetailDebtNote(ctx context.Context, id int32) (DetailDebtNoteRow, error) {
	row := q.db.QueryRowContext(ctx, detailDebtNote, id)
	var i DetailDebtNoteRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Title,
		&i.Entity,
		&i.Money,
		&i.Paymented,
		&i.Note,
		&i.Type,
		&i.Status,
		&i.Company,
		&i.UserCreated,
		&i.Exprise,
		&i.DabtNoteAt,
		&i.ID_2,
		&i.Username,
		&i.HashedPassword,
		&i.FullName,
		&i.Email,
		&i.Type_2,
		&i.OaID,
		&i.IsVerify,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&i.Role,
		&i.Gender,
		&i.Licence,
		&i.Dob,
		&i.Address,
		&i.ID_3,
		&i.FullName_2,
		&i.Code_2,
		&i.Company_2,
		&i.Address_2,
		&i.Email_2,
		&i.Phone,
		&i.License,
		&i.Birthday,
		&i.UserCreated_2,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt_2,
		&i.ID_4,
		&i.Code_3,
		&i.Name,
		&i.DeputyName,
		&i.Phone_2,
		&i.Email_3,
		&i.Address_3,
		&i.Company_3,
		&i.AName,
		&i.CName,
		&i.SName,
	)
	return i, err
}

const getListDebtNote = `-- name: GetListDebtNote :many
SELECT dn.id, dn.code, dn.title, dn.entity, dn.money, dn.paymented, dn.note, dn.type, dn.status, dn.company, dn.user_created, dn.exprise, dn.dabt_note_at, a.full_name AS a_name, c.full_name AS c_name, s.name AS s_name FROM debt_note dn
LEFT JOIN accounts a ON a.id = dn.user_created
LEFT JOIN customers c ON c.code = dn.entity
LEFT JOIN suplier s ON s.code = dn.entity
WHERE dn.company = $1::int
AND (
    $2::varchar IS NULL OR dn.status = $2::varchar
)
AND (
    $3::varchar IS NULL OR dn.type = $3::varchar
)
AND (
    dn.code ILIKE '%' || COALESCE($4::varchar, '') || '%' OR
    dn.title ILIKE '%' || COALESCE($4::varchar, '') || '%'
)
ORDER BY
    CASE WHEN $5::varchar = 'exprise' THEN dn.exprise END DESC,
    CASE WHEN $5::varchar = '-exprise' THEN dn.exprise END ASC,
    CASE WHEN $5::varchar = 'dabt_note_at' THEN dn.dabt_note_at END DESC,
    CASE WHEN $5::varchar = '-dabt_note_at' THEN dn.dabt_note_at END ASC,
    CASE WHEN $5::varchar IS NULL THEN dn.id END DESC
LIMIT COALESCE($7::int, 10)
OFFSET (COALESCE($6::int, 1) - 1) * COALESCE($7::int, 10)
`

type GetListDebtNoteParams struct {
	Company sql.NullInt32  `json:"company"`
	Status  sql.NullString `json:"status"`
	Type    sql.NullString `json:"type"`
	Search  sql.NullString `json:"search"`
	OrderBy sql.NullString `json:"order_by"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

type GetListDebtNoteRow struct {
	ID          int32          `json:"id"`
	Code        string         `json:"code"`
	Title       sql.NullString `json:"title"`
	Entity      string         `json:"entity"`
	Money       float64        `json:"money"`
	Paymented   float64        `json:"paymented"`
	Note        sql.NullString `json:"note"`
	Type        string         `json:"type"`
	Status      string         `json:"status"`
	Company     int32          `json:"company"`
	UserCreated int32          `json:"user_created"`
	Exprise     time.Time      `json:"exprise"`
	DabtNoteAt  sql.NullTime   `json:"dabt_note_at"`
	AName       sql.NullString `json:"a_name"`
	CName       sql.NullString `json:"c_name"`
	SName       sql.NullString `json:"s_name"`
}

// WITH total_repayment AS (
//
//	SELECT debt, COALESCE(SUM(money), 0)::float AS total_money
//	FROM debt_repayment
//	GROUP BY debt
//
// )
// AND  ((
//
//	sqlc.narg('created_start')::timestamp IS NULL AND sqlc.narg('created_end')::timestamp  IS NULL
//
// ) OR (
//
//	(sqlc.narg('created_start')::timestamp IS NULL OR o.created_at >= sqlc.narg('created_start')::timestamp) AND
//	(sqlc.narg('created_end')::timestamp IS NULL OR o.created_at <= sqlc.narg('created_end')::timestamp)
//
// ))
// AND ((
//
//	sqlc.narg('updated_start')::timestamp IS NULL AND sqlc.narg('updated_end')::timestamp  IS NULL
//
// ) OR (
//
//	(o.updated_at >= sqlc.narg('updated_start')::timestamp OR sqlc.narg('updated_start')::timestamp  IS NULL) AND
//	(o.updated_at <= sqlc.narg('updated_end')::timestamp OR sqlc.narg('updated_end')::timestamp  IS NULL)
//
// ))
func (q *Queries) GetListDebtNote(ctx context.Context, arg GetListDebtNoteParams) ([]GetListDebtNoteRow, error) {
	rows, err := q.db.QueryContext(ctx, getListDebtNote,
		arg.Company,
		arg.Status,
		arg.Type,
		arg.Search,
		arg.OrderBy,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListDebtNoteRow{}
	for rows.Next() {
		var i GetListDebtNoteRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Title,
			&i.Entity,
			&i.Money,
			&i.Paymented,
			&i.Note,
			&i.Type,
			&i.Status,
			&i.Company,
			&i.UserCreated,
			&i.Exprise,
			&i.DabtNoteAt,
			&i.AName,
			&i.CName,
			&i.SName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepayment = `-- name: ListRepayment :many
SELECT dr.id, code, money, dr.created_at, debt, user_created, a.id, username, hashed_password, full_name, email, type, oa_id, is_verify, password_changed_at, a.created_at, role, gender, licence, dob, address, a.full_name AS a_name FROM debt_repayment dr
LEFT JOIN accounts a ON a.id = dr.user_created
WHERE dr.debt = $1
`

type ListRepaymentRow struct {
	ID                int32          `json:"id"`
	Code              string         `json:"code"`
	Money             float64        `json:"money"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	Debt              int32          `json:"debt"`
	UserCreated       int32          `json:"user_created"`
	ID_2              sql.NullInt32  `json:"id_2"`
	Username          sql.NullString `json:"username"`
	HashedPassword    sql.NullString `json:"hashed_password"`
	FullName          sql.NullString `json:"full_name"`
	Email             sql.NullString `json:"email"`
	Type              sql.NullInt32  `json:"type"`
	OaID              sql.NullString `json:"oa_id"`
	IsVerify          sql.NullBool   `json:"is_verify"`
	PasswordChangedAt sql.NullTime   `json:"password_changed_at"`
	CreatedAt_2       sql.NullTime   `json:"created_at_2"`
	Role              sql.NullInt32  `json:"role"`
	Gender            NullGender     `json:"gender"`
	Licence           sql.NullString `json:"licence"`
	Dob               sql.NullTime   `json:"dob"`
	Address           sql.NullInt32  `json:"address"`
	AName             sql.NullString `json:"a_name"`
}

func (q *Queries) ListRepayment(ctx context.Context, debt int32) ([]ListRepaymentRow, error) {
	rows, err := q.db.QueryContext(ctx, listRepayment, debt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepaymentRow{}
	for rows.Next() {
		var i ListRepaymentRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Money,
			&i.CreatedAt,
			&i.Debt,
			&i.UserCreated,
			&i.ID_2,
			&i.Username,
			&i.HashedPassword,
			&i.FullName,
			&i.Email,
			&i.Type,
			&i.OaID,
			&i.IsVerify,
			&i.PasswordChangedAt,
			&i.CreatedAt_2,
			&i.Role,
			&i.Gender,
			&i.Licence,
			&i.Dob,
			&i.Address,
			&i.AName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportChartDebtNote = `-- name: ReportChartDebtNote :many
WITH date_series AS (
    SELECT generate_series(current_date - interval '7 days', current_date, interval '1 day')::timestamp AS date
)
SELECT date_series.date AS truncated_date,
       COALESCE(SUM(dn.money), 0)::float AS total_money,
       COALESCE(COUNT(dn.*), 0)::int AS ticket
FROM date_series
LEFT JOIN debt_note dn 
ON DATE_TRUNC('day', dn.dabt_note_at) = date_series.date
    AND ($1::varchar IS NULL OR dn.status = $1::varchar)
    AND ($2::varchar IS NULL OR dn.type = $2::varchar)
    AND dn.company = $3::int
GROUP BY date_series.date
ORDER BY date_series.date
`

type ReportChartDebtNoteParams struct {
	Status  sql.NullString `json:"status"`
	Type    sql.NullString `json:"type"`
	Company int32          `json:"company"`
}

type ReportChartDebtNoteRow struct {
	TruncatedDate time.Time `json:"truncated_date"`
	TotalMoney    float64   `json:"total_money"`
	Ticket        int32     `json:"ticket"`
}

func (q *Queries) ReportChartDebtNote(ctx context.Context, arg ReportChartDebtNoteParams) ([]ReportChartDebtNoteRow, error) {
	rows, err := q.db.QueryContext(ctx, reportChartDebtNote, arg.Status, arg.Type, arg.Company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportChartDebtNoteRow{}
	for rows.Next() {
		var i ReportChartDebtNoteRow
		if err := rows.Scan(&i.TruncatedDate, &i.TotalMoney, &i.Ticket); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportRevenueDebtNote = `-- name: ReportRevenueDebtNote :many
SELECT ds.code, COALESCE(SUM(money), 0)::float AS money, COUNT(dn.*) AS ticket 
FROM debt_note_status ds
LEFT JOIN debt_note dn 
    ON  ds.code = dn.status
    AND ($1::varchar IS NULL OR dn.type = $1::varchar)
    AND dn.company = $2::int
GROUP BY ds.code
`

type ReportRevenueDebtNoteParams struct {
	Type    sql.NullString `json:"type"`
	Company int32          `json:"company"`
}

type ReportRevenueDebtNoteRow struct {
	Code   string  `json:"code"`
	Money  float64 `json:"money"`
	Ticket int64   `json:"ticket"`
}

func (q *Queries) ReportRevenueDebtNote(ctx context.Context, arg ReportRevenueDebtNoteParams) ([]ReportRevenueDebtNoteRow, error) {
	rows, err := q.db.QueryContext(ctx, reportRevenueDebtNote, arg.Type, arg.Company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportRevenueDebtNoteRow{}
	for rows.Next() {
		var i ReportRevenueDebtNoteRow
		if err := rows.Scan(&i.Code, &i.Money, &i.Ticket); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDebtNote = `-- name: UpdateDebtNote :one
UPDATE debt_note
SET
    status = COALESCE($1::varchar, status),
    paymented = COALESCE($2::float, paymented)
WHERE id = $3
RETURNING id, code, title, entity, money, paymented, note, type, status, company, user_created, exprise, dabt_note_at
`

type UpdateDebtNoteParams struct {
	Status    sql.NullString  `json:"status"`
	Paymented sql.NullFloat64 `json:"paymented"`
	ID        int32           `json:"id"`
}

func (q *Queries) UpdateDebtNote(ctx context.Context, arg UpdateDebtNoteParams) (DebtNote, error) {
	row := q.db.QueryRowContext(ctx, updateDebtNote, arg.Status, arg.Paymented, arg.ID)
	var i DebtNote
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Title,
		&i.Entity,
		&i.Money,
		&i.Paymented,
		&i.Note,
		&i.Type,
		&i.Status,
		&i.Company,
		&i.UserCreated,
		&i.Exprise,
		&i.DabtNoteAt,
	)
	return i, err
}
