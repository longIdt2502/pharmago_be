// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: product.sql

package db

import (
	"context"
	"database/sql"
)

const createIngredient = `-- name: CreateIngredient :one
INSERT INTO ingredient (
    name, weight, unit, product
) values (
    $1::varchar, $2::float, $3::varchar, $4::int
) RETURNING id, name, weight, unit, product
`

type CreateIngredientParams struct {
	Name    string        `json:"name"`
	Weight  float64       `json:"weight"`
	Unit    string        `json:"unit"`
	Product sql.NullInt32 `json:"product"`
}

func (q *Queries) CreateIngredient(ctx context.Context, arg CreateIngredientParams) (Ingredient, error) {
	row := q.db.QueryRowContext(ctx, createIngredient,
		arg.Name,
		arg.Weight,
		arg.Unit,
		arg.Product,
	)
	var i Ingredient
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Weight,
		&i.Unit,
		&i.Product,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name, code, product_category, type, brand, unit, ta_duoc, nong_do, lieu_dung, chi_dinh, chong_chi_dinh,
    cong_dung, tac_dung_phu, than_trong, tuong_tac, bao_quan, dong_goi, cong_ty_sx, cong_ty_dk,
    company, user_created, user_updated, phan_loai, dang_bao_che, tieu_chuan_sx
) values (
    $1::varchar, $2::varchar, $3::int, $4::int, $5::int,
    $6::int, $7::varchar, $8::varchar, $9::varchar,
    $10::varchar, $11::varchar, $12::varchar, $13::varchar,
    $14::varchar, $15::varchar, $16::varchar, $17::varchar,
    $18::int, $19::int, $20::int,
    $21::int, $22::int, $23::varchar, $24::varchar, $25::varchar
) RETURNING id, name, code, product_category, type, brand, unit, ta_duoc, nong_do, lieu_dung, chi_dinh, chong_chi_dinh, cong_dung, tac_dung_phu, than_trong, tuong_tac, bao_quan, dong_goi, phan_loai, dang_bao_che, tieu_chuan_sx, cong_ty_sx, cong_ty_dk, active, company, user_created, user_updated, updated_at, created_at
`

type CreateProductParams struct {
	Name            string         `json:"name"`
	Code            string         `json:"code"`
	ProductCategory sql.NullInt32  `json:"product_category"`
	Type            sql.NullInt32  `json:"type"`
	Brand           sql.NullInt32  `json:"brand"`
	Unit            int32          `json:"unit"`
	Taduoc          sql.NullString `json:"taduoc"`
	Nongdo          sql.NullString `json:"nongdo"`
	Lieudung        string         `json:"lieudung"`
	Chidinh         string         `json:"chidinh"`
	Chongchidinh    sql.NullString `json:"chongchidinh"`
	Congdung        string         `json:"congdung"`
	Tacdungphu      string         `json:"tacdungphu"`
	Thantrong       string         `json:"thantrong"`
	Tuongtac        sql.NullString `json:"tuongtac"`
	Baoquan         string         `json:"baoquan"`
	Donggoi         string         `json:"donggoi"`
	Congtysx        int32          `json:"congtysx"`
	Congtydk        int32          `json:"congtydk"`
	Company         int32          `json:"company"`
	UserCreated     int32          `json:"user_created"`
	UserUpdated     int32          `json:"user_updated"`
	Phanloai        string         `json:"phanloai"`
	Dangbaoche      string         `json:"dangbaoche"`
	Tieuchuansx     string         `json:"tieuchuansx"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Code,
		arg.ProductCategory,
		arg.Type,
		arg.Brand,
		arg.Unit,
		arg.Taduoc,
		arg.Nongdo,
		arg.Lieudung,
		arg.Chidinh,
		arg.Chongchidinh,
		arg.Congdung,
		arg.Tacdungphu,
		arg.Thantrong,
		arg.Tuongtac,
		arg.Baoquan,
		arg.Donggoi,
		arg.Congtysx,
		arg.Congtydk,
		arg.Company,
		arg.UserCreated,
		arg.UserUpdated,
		arg.Phanloai,
		arg.Dangbaoche,
		arg.Tieuchuansx,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.ProductCategory,
		&i.Type,
		&i.Brand,
		&i.Unit,
		&i.TaDuoc,
		&i.NongDo,
		&i.LieuDung,
		&i.ChiDinh,
		&i.ChongChiDinh,
		&i.CongDung,
		&i.TacDungPhu,
		&i.ThanTrong,
		&i.TuongTac,
		&i.BaoQuan,
		&i.DongGoi,
		&i.PhanLoai,
		&i.DangBaoChe,
		&i.TieuChuanSx,
		&i.CongTySx,
		&i.CongTyDk,
		&i.Active,
		&i.Company,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createProductMedia = `-- name: CreateProductMedia :one
INSERT INTO product_media (
    product, media
) VALUES ($1, $2) RETURNING id, product, media
`

type CreateProductMediaParams struct {
	Product int32 `json:"product"`
	Media   int32 `json:"media"`
}

func (q *Queries) CreateProductMedia(ctx context.Context, arg CreateProductMediaParams) (ProductMedium, error) {
	row := q.db.QueryRowContext(ctx, createProductMedia, arg.Product, arg.Media)
	var i ProductMedium
	err := row.Scan(&i.ID, &i.Product, &i.Media)
	return i, err
}

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
    name, sell_price, import_price, weight, weight_unit, user_created, user_updated
) values (
    $1::varchar, $2::float, $3::float, $4::float,
    $5::varchar, $6::int, $7::int
) RETURNING id, name, sell_price, import_price, weight, weight_unit, user_created, user_updated, updated_at, created_at
`

type CreateUnitParams struct {
	Name        string          `json:"name"`
	SellPrice   float64         `json:"sell_price"`
	ImportPrice float64         `json:"import_price"`
	Weight      sql.NullFloat64 `json:"weight"`
	WeightUnit  sql.NullString  `json:"weight_unit"`
	UserCreated int32           `json:"user_created"`
	UserUpdated int32           `json:"user_updated"`
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRowContext(ctx, createUnit,
		arg.Name,
		arg.SellPrice,
		arg.ImportPrice,
		arg.Weight,
		arg.WeightUnit,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SellPrice,
		&i.ImportPrice,
		&i.Weight,
		&i.WeightUnit,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUnitChange = `-- name: CreateUnitChange :one
INSERT INTO unit_changes (
    name, value, sell_price, unit, user_created, user_updated
) values (
    $1::varchar, $2::int, $3::float, $4::int,
    $5::int, $6::int
) RETURNING id, name, value, sell_price, unit, user_created, user_updated, updated_at, created_at
`

type CreateUnitChangeParams struct {
	Name        string        `json:"name"`
	Value       int32         `json:"value"`
	SellPrice   float64       `json:"sell_price"`
	Unit        sql.NullInt32 `json:"unit"`
	UserCreated int32         `json:"user_created"`
	UserUpdated int32         `json:"user_updated"`
}

func (q *Queries) CreateUnitChange(ctx context.Context, arg CreateUnitChangeParams) (UnitChange, error) {
	row := q.db.QueryRowContext(ctx, createUnitChange,
		arg.Name,
		arg.Value,
		arg.SellPrice,
		arg.Unit,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i UnitChange
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Value,
		&i.SellPrice,
		&i.Unit,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO variants (
    name, code, barcode, vat, decision_number, register_number, longevity, product, user_created, user_updated
) values (
    $1::varchar, $2::varchar, $3::varchar, $4::float,
    $5::varchar, $6::varchar, $7::varchar,
    $8::int, $9::int, $10::int
) RETURNING id, name, code, barcode, decision_number, register_number, longevity, vat, product, user_created, user_updated, updated_at, created_at
`

type CreateVariantParams struct {
	Name           string          `json:"name"`
	Code           string          `json:"code"`
	Barcode        string          `json:"barcode"`
	Vat            sql.NullFloat64 `json:"vat"`
	DecisionNumber string          `json:"decision_number"`
	RegisterNumber string          `json:"register_number"`
	Longevity      string          `json:"longevity"`
	Product        int32           `json:"product"`
	UserCreated    int32           `json:"user_created"`
	UserUpdated    int32           `json:"user_updated"`
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (Variant, error) {
	row := q.db.QueryRowContext(ctx, createVariant,
		arg.Name,
		arg.Code,
		arg.Barcode,
		arg.Vat,
		arg.DecisionNumber,
		arg.RegisterNumber,
		arg.Longevity,
		arg.Product,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Barcode,
		&i.DecisionNumber,
		&i.RegisterNumber,
		&i.Longevity,
		&i.Vat,
		&i.Product,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createVariantMedia = `-- name: CreateVariantMedia :one
INSERT INTO variant_media (
    variant, media
) VALUES ($1, $2) RETURNING id, variant, media
`

type CreateVariantMediaParams struct {
	Variant int32 `json:"variant"`
	Media   int32 `json:"media"`
}

func (q *Queries) CreateVariantMedia(ctx context.Context, arg CreateVariantMediaParams) (VariantMedium, error) {
	row := q.db.QueryRowContext(ctx, createVariantMedia, arg.Variant, arg.Media)
	var i VariantMedium
	err := row.Scan(&i.ID, &i.Variant, &i.Media)
	return i, err
}

const getProductMedia = `-- name: GetProductMedia :many
SELECT pm.product, pm.media, m.media_url FROM product_media pm
JOIN medias m ON pm.media = m.id
WHERE product = $1
`

type GetProductMediaRow struct {
	Product  int32  `json:"product"`
	Media    int32  `json:"media"`
	MediaUrl string `json:"media_url"`
}

func (q *Queries) GetProductMedia(ctx context.Context, product int32) ([]GetProductMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductMedia, product)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductMediaRow{}
	for rows.Next() {
		var i GetProductMediaRow
		if err := rows.Scan(&i.Product, &i.Media, &i.MediaUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, code, product_category, type, brand, unit, ta_duoc, nong_do, lieu_dung, chi_dinh, chong_chi_dinh, cong_dung, tac_dung_phu, than_trong, tuong_tac, bao_quan, dong_goi, phan_loai, dang_bao_che, tieu_chuan_sx, cong_ty_sx, cong_ty_dk, active, company, user_created, user_updated, updated_at, created_at FROM products
WHERE company = $1::int AND (
    name ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    code ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    ($3::int IS NULL OR brand = $3::int)
)
ORDER BY -id
LIMIT COALESCE($5::int, 10)
OFFSET (COALESCE($4::int, 1) - 1) * COALESCE($5::int, 10)
`

type GetProductsParams struct {
	Company sql.NullInt32  `json:"company"`
	Search  sql.NullString `json:"search"`
	Brand   sql.NullInt32  `json:"brand"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts,
		arg.Company,
		arg.Search,
		arg.Brand,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.ProductCategory,
			&i.Type,
			&i.Brand,
			&i.Unit,
			&i.TaDuoc,
			&i.NongDo,
			&i.LieuDung,
			&i.ChiDinh,
			&i.ChongChiDinh,
			&i.CongDung,
			&i.TacDungPhu,
			&i.ThanTrong,
			&i.TuongTac,
			&i.BaoQuan,
			&i.DongGoi,
			&i.PhanLoai,
			&i.DangBaoChe,
			&i.TieuChuanSx,
			&i.CongTySx,
			&i.CongTyDk,
			&i.Active,
			&i.Company,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    brand = $1
WHERE id = $2
RETURNING id, name, code, product_category, type, brand, unit, ta_duoc, nong_do, lieu_dung, chi_dinh, chong_chi_dinh, cong_dung, tac_dung_phu, than_trong, tuong_tac, bao_quan, dong_goi, phan_loai, dang_bao_che, tieu_chuan_sx, cong_ty_sx, cong_ty_dk, active, company, user_created, user_updated, updated_at, created_at
`

type UpdateProductParams struct {
	Brand sql.NullInt32 `json:"brand"`
	ID    int32         `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct, arg.Brand, arg.ID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.ProductCategory,
		&i.Type,
		&i.Brand,
		&i.Unit,
		&i.TaDuoc,
		&i.NongDo,
		&i.LieuDung,
		&i.ChiDinh,
		&i.ChongChiDinh,
		&i.CongDung,
		&i.TacDungPhu,
		&i.ThanTrong,
		&i.TuongTac,
		&i.BaoQuan,
		&i.DongGoi,
		&i.PhanLoai,
		&i.DangBaoChe,
		&i.TieuChuanSx,
		&i.CongTySx,
		&i.CongTyDk,
		&i.Active,
		&i.Company,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
