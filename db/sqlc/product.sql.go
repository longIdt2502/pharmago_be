// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: product.sql

package db

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name, code, product_category, type, unit, taDuoc, nongDo, lieuDung, chiDinh, chongChiDinh,
    congDung, tacDungPhu, thanTrong, tuongTac, baoQuan, dongGoi, noiSx, congTySx, congTyDk,
    company, user_created, user_updated
) values (
    $1::varchar, $2::varchar, $3::int, $4::int,
    $5::int, $6::varchar, $7::varchar, $8::varchar,
    $9::varchar, $10::varchar, $11::varchar, $12::varchar,
    $13::varchar, $14::varchar, $15::varchar, $16::varchar,
    $17::varchar, $18::varchar, $19::varchar, $20::int,
    $21::int, $22::int
) RETURNING id, name, code, product_category, type, unit, company, user_created, user_updated, updated_at, created_at, taduoc, nongdo, lieudung, chidinh, chongchidinh, congdung, tacdungphu, thantrong, tuongtac, baoquan, donggoi, noisx, congtysx, congtydk, active
`

type CreateProductParams struct {
	Name            string         `json:"name"`
	Code            string         `json:"code"`
	ProductCategory sql.NullInt32  `json:"product_category"`
	Type            sql.NullInt32  `json:"type"`
	Unit            int32          `json:"unit"`
	Taduoc          sql.NullString `json:"taduoc"`
	Nongdo          sql.NullString `json:"nongdo"`
	Lieudung        string         `json:"lieudung"`
	Chidinh         string         `json:"chidinh"`
	Chongchidinh    sql.NullString `json:"chongchidinh"`
	Congdung        string         `json:"congdung"`
	Tacdungphu      string         `json:"tacdungphu"`
	Thantrong       string         `json:"thantrong"`
	Tuongtac        sql.NullString `json:"tuongtac"`
	Baoquan         string         `json:"baoquan"`
	Donggoi         string         `json:"donggoi"`
	Noisx           string         `json:"noisx"`
	Congtysx        string         `json:"congtysx"`
	Congtydk        string         `json:"congtydk"`
	Company         int32          `json:"company"`
	UserCreated     int32          `json:"user_created"`
	UserUpdated     int32          `json:"user_updated"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Code,
		arg.ProductCategory,
		arg.Type,
		arg.Unit,
		arg.Taduoc,
		arg.Nongdo,
		arg.Lieudung,
		arg.Chidinh,
		arg.Chongchidinh,
		arg.Congdung,
		arg.Tacdungphu,
		arg.Thantrong,
		arg.Tuongtac,
		arg.Baoquan,
		arg.Donggoi,
		arg.Noisx,
		arg.Congtysx,
		arg.Congtydk,
		arg.Company,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.ProductCategory,
		&i.Type,
		&i.Unit,
		&i.Company,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Taduoc,
		&i.Nongdo,
		&i.Lieudung,
		&i.Chidinh,
		&i.Chongchidinh,
		&i.Congdung,
		&i.Tacdungphu,
		&i.Thantrong,
		&i.Tuongtac,
		&i.Baoquan,
		&i.Donggoi,
		&i.Noisx,
		&i.Congtysx,
		&i.Congtydk,
		&i.Active,
	)
	return i, err
}

const createProductMedia = `-- name: CreateProductMedia :one
INSERT INTO product_media (
    product, media
) VALUES ($1, $2) RETURNING id, product, media
`

type CreateProductMediaParams struct {
	Product sql.NullInt64 `json:"product"`
	Media   sql.NullInt64 `json:"media"`
}

func (q *Queries) CreateProductMedia(ctx context.Context, arg CreateProductMediaParams) (ProductMedium, error) {
	row := q.db.QueryRowContext(ctx, createProductMedia, arg.Product, arg.Media)
	var i ProductMedium
	err := row.Scan(&i.ID, &i.Product, &i.Media)
	return i, err
}

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
    name, sell_price, import_price, weight, weight_unit, user_created, user_updated
) values (
    $1::varchar, $2::float, $3::float, $4::float,
    $5::varchar, $6::int, $7::int
) RETURNING id, name, sell_price, import_price, weight, weight_unit, user_created, user_updated, updated_at, created_at
`

type CreateUnitParams struct {
	Name        string          `json:"name"`
	SellPrice   float64         `json:"sell_price"`
	ImportPrice float64         `json:"import_price"`
	Weight      sql.NullFloat64 `json:"weight"`
	WeightUnit  sql.NullString  `json:"weight_unit"`
	UserCreated int32           `json:"user_created"`
	UserUpdated int32           `json:"user_updated"`
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRowContext(ctx, createUnit,
		arg.Name,
		arg.SellPrice,
		arg.ImportPrice,
		arg.Weight,
		arg.WeightUnit,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SellPrice,
		&i.ImportPrice,
		&i.Weight,
		&i.WeightUnit,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO variants (
    name, code, barcode, vat, decision_number, register_number, longevity, product, user_created, user_updated
) values (
    $1::varchar, $2::varchar, $3::varchar, $4::float,
    $5::varchar, $6::varchar, $7::varchar,
    $8::int, $9::int, $10::int
) RETURNING id, name, code, barcode, decision_number, register_number, vat, product, user_created, user_updated, updated_at, created_at, longevity
`

type CreateVariantParams struct {
	Name           string          `json:"name"`
	Code           string          `json:"code"`
	Barcode        string          `json:"barcode"`
	Vat            sql.NullFloat64 `json:"vat"`
	DecisionNumber string          `json:"decision_number"`
	RegisterNumber string          `json:"register_number"`
	Longevity      string          `json:"longevity"`
	Product        int32           `json:"product"`
	UserCreated    int32           `json:"user_created"`
	UserUpdated    int32           `json:"user_updated"`
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (Variant, error) {
	row := q.db.QueryRowContext(ctx, createVariant,
		arg.Name,
		arg.Code,
		arg.Barcode,
		arg.Vat,
		arg.DecisionNumber,
		arg.RegisterNumber,
		arg.Longevity,
		arg.Product,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Barcode,
		&i.DecisionNumber,
		&i.RegisterNumber,
		&i.Vat,
		&i.Product,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Longevity,
	)
	return i, err
}

const createVariantMedia = `-- name: CreateVariantMedia :one
INSERT INTO variant_media (
    variant, media
) VALUES ($1, $2) RETURNING id, variant, media
`

type CreateVariantMediaParams struct {
	Variant int64 `json:"variant"`
	Media   int64 `json:"media"`
}

func (q *Queries) CreateVariantMedia(ctx context.Context, arg CreateVariantMediaParams) (VariantMedium, error) {
	row := q.db.QueryRowContext(ctx, createVariantMedia, arg.Variant, arg.Media)
	var i VariantMedium
	err := row.Scan(&i.ID, &i.Variant, &i.Media)
	return i, err
}

const getProductMedia = `-- name: GetProductMedia :many
SELECT pm.product, pm.media, m.media_url FROM product_media pm
JOIN medias m ON pm.media = m.id
WHERE product = $1
`

type GetProductMediaRow struct {
	Product  sql.NullInt64 `json:"product"`
	Media    sql.NullInt64 `json:"media"`
	MediaUrl string        `json:"media_url"`
}

func (q *Queries) GetProductMedia(ctx context.Context, product sql.NullInt64) ([]GetProductMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductMedia, product)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductMediaRow{}
	for rows.Next() {
		var i GetProductMediaRow
		if err := rows.Scan(&i.Product, &i.Media, &i.MediaUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, code, product_category, type, unit, company, user_created, user_updated, updated_at, created_at, taduoc, nongdo, lieudung, chidinh, chongchidinh, congdung, tacdungphu, thantrong, tuongtac, baoquan, donggoi, noisx, congtysx, congtydk, active FROM products
WHERE company = $1::int AND (
    name ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    code ILIKE '%' || COALESCE($2::varchar, '') || '%'
)
ORDER BY -id
LIMIT COALESCE($4::int, 10)
OFFSET (COALESCE($3::int, 1) - 1) * COALESCE($4::int, 10)
`

type GetProductsParams struct {
	Company sql.NullInt32  `json:"company"`
	Search  sql.NullString `json:"search"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts,
		arg.Company,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.ProductCategory,
			&i.Type,
			&i.Unit,
			&i.Company,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Taduoc,
			&i.Nongdo,
			&i.Lieudung,
			&i.Chidinh,
			&i.Chongchidinh,
			&i.Congdung,
			&i.Tacdungphu,
			&i.Thantrong,
			&i.Tuongtac,
			&i.Baoquan,
			&i.Donggoi,
			&i.Noisx,
			&i.Congtysx,
			&i.Congtydk,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
