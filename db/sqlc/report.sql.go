// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: report.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getReportRevenue = `-- name: GetReportRevenue :many
WITH date_series AS (
    SELECT
        generate_series(
            date_trunc(
                CASE
                    WHEN COALESCE($1 :: varchar, 'day') = 'day' THEN 'month'
                    WHEN COALESCE($1 :: varchar, 'day') = 'month' THEN 'year'
                    ELSE 'month'
                END,
                current_date
            ),
            current_date,
            CASE
                WHEN COALESCE($1 :: varchar, 'day') = 'day' THEN interval '1 day'
                WHEN COALESCE($1 :: varchar, 'day') = 'month' THEN interval '1 month'
                ELSE interval '1 day'
            END
        ) :: timestamp AS date
),
order_series As (
    SELECT
        id, code, total_price, description, vat, discount, service_price, must_paid, customer, address, status, type, ticket, qr, company, payment, user_created, user_updated, created_at, updated_at
    FROM
        orders
    WHERE
        company = $2 :: int
        AND (
            $3 :: varchar IS NULL
            OR status = $3 :: varchar
        )
)
SELECT
    ds.date,
    COALESCE(SUM(o1.total_price), 0)::float AS current_revenue,
    COALESCE(SUM(o2.total_price), 0)::float AS last_revenue
FROM
    date_series ds
    LEFT JOIN order_series o1 ON date_trunc(
        COALESCE($1 :: varchar, 'day'),
        o1.created_at
    ) = ds.date
    LEFT JOIN order_series o2 ON date_trunc(
        COALESCE($1 :: varchar, 'day'),
        o2.created_at
    ) = date_trunc(
        COALESCE($1 :: varchar, 'day'),
        ds.date - CASE
            WHEN COALESCE($1 :: varchar, 'day') = 'day' THEN interval '1 month'
            WHEN COALESCE($1 :: varchar, 'day') = 'month' THEN interval '1 year'
            ELSE interval '1 day'
        END
    )
GROUP BY
    ds.date
`

type GetReportRevenueParams struct {
	Filter  string         `json:"filter"`
	Company int32          `json:"company"`
	Status  sql.NullString `json:"status"`
}

type GetReportRevenueRow struct {
	Date           time.Time `json:"date"`
	CurrentRevenue float64   `json:"current_revenue"`
	LastRevenue    float64   `json:"last_revenue"`
}

func (q *Queries) GetReportRevenue(ctx context.Context, arg GetReportRevenueParams) ([]GetReportRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportRevenue, arg.Filter, arg.Company, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReportRevenueRow{}
	for rows.Next() {
		var i GetReportRevenueRow
		if err := rows.Scan(&i.Date, &i.CurrentRevenue, &i.LastRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueCompany = `-- name: GetRevenueCompany :one
SELECT
    COALESCE(SUM(total_price), 0) :: float AS total_sum
FROM
    orders
WHERE
    status = 'COMPLETE'
    AND type = 'SELL'
    AND company = $1
`

func (q *Queries) GetRevenueCompany(ctx context.Context, company int32) (float64, error) {
	row := q.db.QueryRowContext(ctx, getRevenueCompany, company)
	var total_sum float64
	err := row.Scan(&total_sum)
	return total_sum, err
}

const getVariantBestSale = `-- name: GetVariantBestSale :many
WITH variant_total AS (
    SELECT
        v.id AS variant_id,
        COALESCE(SUM(oi.total_price), 0) :: float AS total_revenue
    FROM
        variants v
        LEFT JOIN order_items oi ON v.id = oi.variant
        LEFT JOIN orders o ON o.id = oi.order
    WHERE
        o.status = 'COMPLETE'
    GROUP BY
        v.id
)
SELECT
    v.id, v.name, v.code, v.barcode, v.decision_number, v.register_number, v.longevity, v.vat, v.product, v.user_created, v.user_updated, v.updated_at, v.created_at, v.initial_inventory, v.real_inventory,
    vt.total_revenue AS revenue,
    m.media_url AS imageUrl
FROM
    variant_total vt
    JOIN variants v ON v.id = vt.variant_id
    JOIN products p ON v.product = p.id
    JOIN variant_media vm ON vm.variant = v.id
    JOIN medias m ON vm.media = m.id
WHERE
    p.company = $1
ORDER BY
    vt.total_revenue DESC
LIMIT
    3
`

type GetVariantBestSaleRow struct {
	ID               int32           `json:"id"`
	Name             string          `json:"name"`
	Code             string          `json:"code"`
	Barcode          sql.NullString  `json:"barcode"`
	DecisionNumber   sql.NullString  `json:"decision_number"`
	RegisterNumber   sql.NullString  `json:"register_number"`
	Longevity        sql.NullString  `json:"longevity"`
	Vat              sql.NullFloat64 `json:"vat"`
	Product          int32           `json:"product"`
	UserCreated      int32           `json:"user_created"`
	UserUpdated      sql.NullInt32   `json:"user_updated"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	CreatedAt        time.Time       `json:"created_at"`
	InitialInventory int32           `json:"initial_inventory"`
	RealInventory    int32           `json:"real_inventory"`
	Revenue          float64         `json:"revenue"`
	Imageurl         string          `json:"imageurl"`
}

func (q *Queries) GetVariantBestSale(ctx context.Context, company int32) ([]GetVariantBestSaleRow, error) {
	rows, err := q.db.QueryContext(ctx, getVariantBestSale, company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVariantBestSaleRow{}
	for rows.Next() {
		var i GetVariantBestSaleRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Barcode,
			&i.DecisionNumber,
			&i.RegisterNumber,
			&i.Longevity,
			&i.Vat,
			&i.Product,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.InitialInventory,
			&i.RealInventory,
			&i.Revenue,
			&i.Imageurl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reportCustomerRevenue = `-- name: ReportCustomerRevenue :many
WITH revenue AS (
    SELECT COUNT(id) AS count_order, SUM(total_price)::float AS total_price, customer FROM orders
    WHERE company = $2::int
    GROUP BY customer
)
SELECT r.count_order, r.total_price, r.customer, c.id, c.full_name, c.code, c.company, c.address, c.email, c.phone, c.license, c.birthday, c.user_created, c.user_updated, c.updated_at, c.created_at, c."group", c.title, c.license_date, c.contact_name, c.contact_title, c.contact_phone, c.contact_email, c.contact_address, c.account_number, c.bank_name, c.bank_branch FROM revenue r
LEFT JOIN customers c ON r.customer = c.id
ORDER BY 
    CASE WHEN $1::varchar = 'quantity' THEN -r.count_order
         WHEN $1::varchar = 'revenue' THEN -r.total_price
         ELSE -r.count_order
    END
LIMIT 5
`

type ReportCustomerRevenueParams struct {
	OrderBy string `json:"order_by"`
	Company int32  `json:"company"`
}

type ReportCustomerRevenueRow struct {
	CountOrder     int64          `json:"count_order"`
	TotalPrice     float64        `json:"total_price"`
	Customer       sql.NullInt32  `json:"customer"`
	ID             sql.NullInt32  `json:"id"`
	FullName       sql.NullString `json:"full_name"`
	Code           sql.NullString `json:"code"`
	Company        sql.NullInt32  `json:"company"`
	Address        sql.NullInt32  `json:"address"`
	Email          sql.NullString `json:"email"`
	Phone          sql.NullString `json:"phone"`
	License        sql.NullString `json:"license"`
	Birthday       sql.NullTime   `json:"birthday"`
	UserCreated    sql.NullInt32  `json:"user_created"`
	UserUpdated    sql.NullInt32  `json:"user_updated"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	Group          sql.NullInt32  `json:"group"`
	Title          sql.NullString `json:"title"`
	LicenseDate    sql.NullTime   `json:"license_date"`
	ContactName    sql.NullString `json:"contact_name"`
	ContactTitle   sql.NullString `json:"contact_title"`
	ContactPhone   sql.NullString `json:"contact_phone"`
	ContactEmail   sql.NullString `json:"contact_email"`
	ContactAddress sql.NullInt32  `json:"contact_address"`
	AccountNumber  sql.NullString `json:"account_number"`
	BankName       sql.NullString `json:"bank_name"`
	BankBranch     sql.NullString `json:"bank_branch"`
}

func (q *Queries) ReportCustomerRevenue(ctx context.Context, arg ReportCustomerRevenueParams) ([]ReportCustomerRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, reportCustomerRevenue, arg.OrderBy, arg.Company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportCustomerRevenueRow{}
	for rows.Next() {
		var i ReportCustomerRevenueRow
		if err := rows.Scan(
			&i.CountOrder,
			&i.TotalPrice,
			&i.Customer,
			&i.ID,
			&i.FullName,
			&i.Code,
			&i.Company,
			&i.Address,
			&i.Email,
			&i.Phone,
			&i.License,
			&i.Birthday,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Group,
			&i.Title,
			&i.LicenseDate,
			&i.ContactName,
			&i.ContactTitle,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.ContactAddress,
			&i.AccountNumber,
			&i.BankName,
			&i.BankBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalCustomerByMonth = `-- name: TotalCustomerByMonth :many
WITH time_generate AS (
	SELECT
        generate_series(
            date_trunc('year',
                current_date
            ),
            date_trunc('year',
                current_date + INTERVAL '1 year'
            ),
            interval '1 month'
        ) :: timestamp AS date LIMIT 12
)
SELECT tg.date, COALESCE(COUNT(c.id), 0)::int AS count from time_generate tg
LEFT JOIN customers c ON date_trunc('month', c.created_at) = tg.date 
AND c.company = $1::int
GROUP BY tg.date
`

type TotalCustomerByMonthRow struct {
	Date  time.Time `json:"date"`
	Count int32     `json:"count"`
}

func (q *Queries) TotalCustomerByMonth(ctx context.Context, company int32) ([]TotalCustomerByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, totalCustomerByMonth, company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TotalCustomerByMonthRow{}
	for rows.Next() {
		var i TotalCustomerByMonthRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalOrderByMonth = `-- name: TotalOrderByMonth :many
WITH time_generate AS (
	SELECT
        generate_series(
            date_trunc('year',
                current_date
            ),
            date_trunc('year',
                current_date + INTERVAL '1 year'
            ),
            interval '1 month'
        ) :: timestamp AS date LIMIT 12
)
SELECT tg.date, COALESCE(COUNT(o.id), 0)::int AS count from time_generate tg
LEFT JOIN orders o ON date_trunc('month', o.created_at) = tg.date 
AND o.company = $1::int
GROUP BY tg.date
`

type TotalOrderByMonthRow struct {
	Date  time.Time `json:"date"`
	Count int32     `json:"count"`
}

func (q *Queries) TotalOrderByMonth(ctx context.Context, company int32) ([]TotalOrderByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, totalOrderByMonth, company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TotalOrderByMonthRow{}
	for rows.Next() {
		var i TotalOrderByMonthRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalRevenue = `-- name: TotalRevenue :one
SELECT COALESCE(SUM(total_price), 0)::float AS value FROM orders
WHERE company = $1 :: int AND date_trunc(
    COALESCE($2 :: varchar, 'month'),
    created_at
) = date_trunc(COALESCE($2 :: varchar, 'month'), current_date - 
    CASE 
        WHEN COALESCE($2 :: varchar, 'month') = 'month' THEN MAKE_INTERVAL(
            months => COALESCE($3 :: int, 0)
        )::interval
        WHEN COALESCE($2 :: varchar, 'month') = 'year' THEN MAKE_INTERVAL(
            years => COALESCE($3 :: int, 0)
        )::interval
        ELSE interval '0 month'    
    END
    )
`

type TotalRevenueParams struct {
	Company  int32  `json:"company"`
	Filter   string `json:"filter"`
	Interval int32  `json:"interval"`
}

func (q *Queries) TotalRevenue(ctx context.Context, arg TotalRevenueParams) (float64, error) {
	row := q.db.QueryRowContext(ctx, totalRevenue, arg.Company, arg.Filter, arg.Interval)
	var value float64
	err := row.Scan(&value)
	return value, err
}
