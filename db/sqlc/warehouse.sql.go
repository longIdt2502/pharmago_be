// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: warehouse.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countTicketByStatus = `-- name: CountTicketByStatus :one
SELECT COUNT(*) FROM tickets t
JOIN ticket_status ts ON t.status = ts.id
WHERE ts.code = $1
`

func (q *Queries) CountTicketByStatus(ctx context.Context, code string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketByStatus, code)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConsignment = `-- name: CreateConsignment :one
INSERT INTO consignment (
    code, quantity, inventory, ticket, variant, expired_at, producted_at, user_created, user_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

type CreateConsignmentParams struct {
	Code        string        `json:"code"`
	Quantity    int32         `json:"quantity"`
	Inventory   int32         `json:"inventory"`
	Ticket      sql.NullInt32 `json:"ticket"`
	Variant     sql.NullInt32 `json:"variant"`
	ExpiredAt   time.Time     `json:"expired_at"`
	ProductedAt time.Time     `json:"producted_at"`
	UserCreated sql.NullInt32 `json:"user_created"`
	UserUpdated sql.NullInt32 `json:"user_updated"`
}

func (q *Queries) CreateConsignment(ctx context.Context, arg CreateConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, createConsignment,
		arg.Code,
		arg.Quantity,
		arg.Inventory,
		arg.Ticket,
		arg.Variant,
		arg.ExpiredAt,
		arg.ProductedAt,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const createConsignmentLog = `-- name: CreateConsignmentLog :one
INSERT INTO consignment_log (
    consignment, inventory, amount_change, user_created
) VALUES (
     $1, $2, $3, $4
) RETURNING id, consignment, inventory, amount_change, user_created, created_at
`

type CreateConsignmentLogParams struct {
	Consignment  int32         `json:"consignment"`
	Inventory    int32         `json:"inventory"`
	AmountChange int32         `json:"amount_change"`
	UserCreated  sql.NullInt32 `json:"user_created"`
}

func (q *Queries) CreateConsignmentLog(ctx context.Context, arg CreateConsignmentLogParams) (ConsignmentLog, error) {
	row := q.db.QueryRowContext(ctx, createConsignmentLog,
		arg.Consignment,
		arg.Inventory,
		arg.AmountChange,
		arg.UserCreated,
	)
	var i ConsignmentLog
	err := row.Scan(
		&i.ID,
		&i.Consignment,
		&i.Inventory,
		&i.AmountChange,
		&i.UserCreated,
		&i.CreatedAt,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (
    code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated, updated_at, created_at
`

type CreateTicketParams struct {
	Code        string         `json:"code"`
	Type        sql.NullInt32  `json:"type"`
	Status      sql.NullInt32  `json:"status"`
	Note        sql.NullString `json:"note"`
	Qr          sql.NullInt32  `json:"qr"`
	ExportTo    sql.NullInt32  `json:"export_to"`
	ImportFrom  sql.NullInt32  `json:"import_from"`
	TotalPrice  float64        `json:"total_price"`
	Warehouse   int32          `json:"warehouse"`
	UserCreated int32          `json:"user_created"`
	UserUpdated sql.NullInt32  `json:"user_updated"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.Note,
		arg.Qr,
		arg.ExportTo,
		arg.ImportFrom,
		arg.TotalPrice,
		arg.Warehouse,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Note,
		&i.Qr,
		&i.ExportTo,
		&i.ImportFrom,
		&i.TotalPrice,
		&i.Warehouse,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWarehouse = `-- name: CreateWarehouse :one
INSERT INTO warehouses (
    name, code, address, companies
) VALUES (
    $1, $2, $3, $4
) RETURNING id, address, companies, name, code
`

type CreateWarehouseParams struct {
	Name      string        `json:"name"`
	Code      string        `json:"code"`
	Address   sql.NullInt32 `json:"address"`
	Companies sql.NullInt32 `json:"companies"`
}

func (q *Queries) CreateWarehouse(ctx context.Context, arg CreateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, createWarehouse,
		arg.Name,
		arg.Code,
		arg.Address,
		arg.Companies,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const deleteWarehouse = `-- name: DeleteWarehouse :one
DELETE FROM warehouses
WHERE id = $1 RETURNING id, address, companies, name, code
`

func (q *Queries) DeleteWarehouse(ctx context.Context, id int32) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, deleteWarehouse, id)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const detailWarehouse = `-- name: DetailWarehouse :one
SELECT id, address, companies, name, code FROM warehouses
WHERE id = $1
`

func (q *Queries) DetailWarehouse(ctx context.Context, id int32) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, detailWarehouse, id)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const getConsignment = `-- name: GetConsignment :one
SELECT id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant FROM consignment
WHERE id = $1 AND variant = $2
LIMIT 1
`

type GetConsignmentParams struct {
	ID      int32         `json:"id"`
	Variant sql.NullInt32 `json:"variant"`
}

func (q *Queries) GetConsignment(ctx context.Context, arg GetConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, getConsignment, arg.ID, arg.Variant)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const getConsignments = `-- name: GetConsignments :many
SELECT c.id, c.code, quantity, inventory, ticket, expired_at, producted_at, is_available, c.user_created, c.user_updated, c.updated_at, c.created_at, variant, t.id, t.code, type, status, note, qr, export_to, import_from, total_price, warehouse, t.user_created, t.user_updated, t.updated_at, t.created_at, w.id, address, companies, name, w.code FROM consignment c
JOIN tickets t ON c.ticket = t.id
JOIN warehouses w ON t.warehouse = w.id
WHERE w.companies = $1::int
AND ($2::bool IS NULL OR c.is_available = $2::bool)
AND (
    $3::int IS NULL OR
    w.id = $3::int
)
AND (
    c.code ILIKE '%' || COALESCE($4::varchar, '') || '%'
)
ORDER BY -c.id
LIMIT COALESCE($6::int, 10)
OFFSET (COALESCE($5::int, 1) - 1) * COALESCE($6::int, 10)
`

type GetConsignmentsParams struct {
	Company   int32          `json:"company"`
	Available sql.NullBool   `json:"available"`
	Warehouse sql.NullInt32  `json:"warehouse"`
	Search    sql.NullString `json:"search"`
	Page      sql.NullInt32  `json:"page"`
	Limit     sql.NullInt32  `json:"limit"`
}

type GetConsignmentsRow struct {
	ID            int32          `json:"id"`
	Code          string         `json:"code"`
	Quantity      int32          `json:"quantity"`
	Inventory     int32          `json:"inventory"`
	Ticket        sql.NullInt32  `json:"ticket"`
	ExpiredAt     time.Time      `json:"expired_at"`
	ProductedAt   time.Time      `json:"producted_at"`
	IsAvailable   bool           `json:"is_available"`
	UserCreated   sql.NullInt32  `json:"user_created"`
	UserUpdated   sql.NullInt32  `json:"user_updated"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	CreatedAt     time.Time      `json:"created_at"`
	Variant       sql.NullInt32  `json:"variant"`
	ID_2          int32          `json:"id_2"`
	Code_2        string         `json:"code_2"`
	Type          sql.NullInt32  `json:"type"`
	Status        sql.NullInt32  `json:"status"`
	Note          sql.NullString `json:"note"`
	Qr            sql.NullInt32  `json:"qr"`
	ExportTo      sql.NullInt32  `json:"export_to"`
	ImportFrom    sql.NullInt32  `json:"import_from"`
	TotalPrice    float64        `json:"total_price"`
	Warehouse     int32          `json:"warehouse"`
	UserCreated_2 int32          `json:"user_created_2"`
	UserUpdated_2 sql.NullInt32  `json:"user_updated_2"`
	UpdatedAt_2   sql.NullTime   `json:"updated_at_2"`
	CreatedAt_2   time.Time      `json:"created_at_2"`
	ID_3          int32          `json:"id_3"`
	Address       sql.NullInt32  `json:"address"`
	Companies     sql.NullInt32  `json:"companies"`
	Name          string         `json:"name"`
	Code_3        string         `json:"code_3"`
}

func (q *Queries) GetConsignments(ctx context.Context, arg GetConsignmentsParams) ([]GetConsignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getConsignments,
		arg.Company,
		arg.Available,
		arg.Warehouse,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConsignmentsRow{}
	for rows.Next() {
		var i GetConsignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Variant,
			&i.ID_2,
			&i.Code_2,
			&i.Type,
			&i.Status,
			&i.Note,
			&i.Qr,
			&i.ExportTo,
			&i.ImportFrom,
			&i.TotalPrice,
			&i.Warehouse,
			&i.UserCreated_2,
			&i.UserUpdated_2,
			&i.UpdatedAt_2,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDetailTicket = `-- name: GetDetailTicket :one
SELECT t.id, t.code, t.type, status, note, qr, export_to, import_from, total_price, warehouse, t.user_created, t.user_updated, t.updated_at, t.created_at, s.id, s.code, s.name, deputy_name, s.phone, s.email, s.address, s.company, c.id, c.full_name, c.code, c.company, c.address, c.email, c.phone, license, birthday, c.user_created, c.user_updated, c.updated_at, c.created_at, w.id, w.address, companies, w.name, w.code, tt.id, tt.code, tt.title, ts.id, ts.code, ts.title, m.id, media_url, a_uc.id, a_uc.username, a_uc.hashed_password, a_uc.full_name, a_uc.email, a_uc.type, a_uc.is_verify, a_uc.password_changed_at, a_uc.created_at, a_uc.role, a_uc.gender, a_uc.licence, a_uc.dob, a_uc.address, a_uu.id, a_uu.username, a_uu.hashed_password, a_uu.full_name, a_uu.email, a_uu.type, a_uu.is_verify, a_uu.password_changed_at, a_uu.created_at, a_uu.role, a_uu.gender, a_uu.licence, a_uu.dob, a_uu.address , m.media_url AS qr_url, a_uc.full_name AS user_created_name, a_uu.full_name AS user_updated_name,
       w.id AS w_id, w.name AS w_name, w.code AS w_code, w.address AS w_address,
        c.id AS c_id, c.full_name AS c_name, c.code AS c_code, c.address AS c_address, c.email AS c_email, c.phone AS c_phone, c.company AS c_company,
        s.id AS s_id, s.code AS s_code, s.name AS s_name, s.deputy_name AS s_deputy, s.phone AS s_phone, s.email AS s_email, s.address AS s_address, s.company AS s_company,
       tt.id AS tt_id, tt.code AS tt_code, tt.title AS tt_title,
       ts.id AS ts_id, ts.code AS ts_code, ts.title AS ts_title
FROM tickets t
LEFT JOIN suplier s ON t.import_from = s.address AND t.type = 1
LEFT JOIN customers c ON t.export_to = c.address AND t.type = 2
JOIN warehouses w ON w.id = t.warehouse
JOIN ticket_type tt ON t.type = tt.id
JOIN ticket_status ts ON t.status = ts.id
JOIN medias m ON t.qr = m.id
JOIN accounts a_uc ON a_uc.id = t.user_created
JOIN accounts a_uu ON a_uu.id = t.user_updated
WHERE t.id = $1
`

type GetDetailTicketRow struct {
	ID                  int32          `json:"id"`
	Code                string         `json:"code"`
	Type                sql.NullInt32  `json:"type"`
	Status              sql.NullInt32  `json:"status"`
	Note                sql.NullString `json:"note"`
	Qr                  sql.NullInt32  `json:"qr"`
	ExportTo            sql.NullInt32  `json:"export_to"`
	ImportFrom          sql.NullInt32  `json:"import_from"`
	TotalPrice          float64        `json:"total_price"`
	Warehouse           int32          `json:"warehouse"`
	UserCreated         int32          `json:"user_created"`
	UserUpdated         sql.NullInt32  `json:"user_updated"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	CreatedAt           time.Time      `json:"created_at"`
	ID_2                sql.NullInt32  `json:"id_2"`
	Code_2              sql.NullString `json:"code_2"`
	Name                sql.NullString `json:"name"`
	DeputyName          sql.NullString `json:"deputy_name"`
	Phone               sql.NullString `json:"phone"`
	Email               sql.NullString `json:"email"`
	Address             sql.NullInt32  `json:"address"`
	Company             sql.NullInt32  `json:"company"`
	ID_3                sql.NullInt32  `json:"id_3"`
	FullName            sql.NullString `json:"full_name"`
	Code_3              sql.NullString `json:"code_3"`
	Company_2           sql.NullInt32  `json:"company_2"`
	Address_2           sql.NullInt32  `json:"address_2"`
	Email_2             sql.NullString `json:"email_2"`
	Phone_2             sql.NullString `json:"phone_2"`
	License             sql.NullString `json:"license"`
	Birthday            sql.NullTime   `json:"birthday"`
	UserCreated_2       sql.NullInt32  `json:"user_created_2"`
	UserUpdated_2       sql.NullInt32  `json:"user_updated_2"`
	UpdatedAt_2         sql.NullTime   `json:"updated_at_2"`
	CreatedAt_2         sql.NullTime   `json:"created_at_2"`
	ID_4                int32          `json:"id_4"`
	Address_3           sql.NullInt32  `json:"address_3"`
	Companies           sql.NullInt32  `json:"companies"`
	Name_2              string         `json:"name_2"`
	Code_4              string         `json:"code_4"`
	ID_5                int32          `json:"id_5"`
	Code_5              string         `json:"code_5"`
	Title               string         `json:"title"`
	ID_6                int32          `json:"id_6"`
	Code_6              string         `json:"code_6"`
	Title_2             string         `json:"title_2"`
	ID_7                int32          `json:"id_7"`
	MediaUrl            string         `json:"media_url"`
	ID_8                int32          `json:"id_8"`
	Username            string         `json:"username"`
	HashedPassword      string         `json:"hashed_password"`
	FullName_2          string         `json:"full_name_2"`
	Email_3             string         `json:"email_3"`
	Type_2              int32          `json:"type_2"`
	IsVerify            bool           `json:"is_verify"`
	PasswordChangedAt   time.Time      `json:"password_changed_at"`
	CreatedAt_3         time.Time      `json:"created_at_3"`
	Role                sql.NullInt32  `json:"role"`
	Gender              NullGender     `json:"gender"`
	Licence             sql.NullString `json:"licence"`
	Dob                 sql.NullTime   `json:"dob"`
	Address_4           sql.NullInt32  `json:"address_4"`
	ID_9                int32          `json:"id_9"`
	Username_2          string         `json:"username_2"`
	HashedPassword_2    string         `json:"hashed_password_2"`
	FullName_3          string         `json:"full_name_3"`
	Email_4             string         `json:"email_4"`
	Type_3              int32          `json:"type_3"`
	IsVerify_2          bool           `json:"is_verify_2"`
	PasswordChangedAt_2 time.Time      `json:"password_changed_at_2"`
	CreatedAt_4         time.Time      `json:"created_at_4"`
	Role_2              sql.NullInt32  `json:"role_2"`
	Gender_2            NullGender     `json:"gender_2"`
	Licence_2           sql.NullString `json:"licence_2"`
	Dob_2               sql.NullTime   `json:"dob_2"`
	Address_5           sql.NullInt32  `json:"address_5"`
	QrUrl               string         `json:"qr_url"`
	UserCreatedName     string         `json:"user_created_name"`
	UserUpdatedName     string         `json:"user_updated_name"`
	WID                 int32          `json:"w_id"`
	WName               string         `json:"w_name"`
	WCode               string         `json:"w_code"`
	WAddress            sql.NullInt32  `json:"w_address"`
	CID                 sql.NullInt32  `json:"c_id"`
	CName               sql.NullString `json:"c_name"`
	CCode               sql.NullString `json:"c_code"`
	CAddress            sql.NullInt32  `json:"c_address"`
	CEmail              sql.NullString `json:"c_email"`
	CPhone              sql.NullString `json:"c_phone"`
	CCompany            sql.NullInt32  `json:"c_company"`
	SID                 sql.NullInt32  `json:"s_id"`
	SCode               sql.NullString `json:"s_code"`
	SName               sql.NullString `json:"s_name"`
	SDeputy             sql.NullString `json:"s_deputy"`
	SPhone              sql.NullString `json:"s_phone"`
	SEmail              sql.NullString `json:"s_email"`
	SAddress            sql.NullInt32  `json:"s_address"`
	SCompany            sql.NullInt32  `json:"s_company"`
	TtID                int32          `json:"tt_id"`
	TtCode              string         `json:"tt_code"`
	TtTitle             string         `json:"tt_title"`
	TsID                int32          `json:"ts_id"`
	TsCode              string         `json:"ts_code"`
	TsTitle             string         `json:"ts_title"`
}

func (q *Queries) GetDetailTicket(ctx context.Context, id int32) (GetDetailTicketRow, error) {
	row := q.db.QueryRowContext(ctx, getDetailTicket, id)
	var i GetDetailTicketRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Note,
		&i.Qr,
		&i.ExportTo,
		&i.ImportFrom,
		&i.TotalPrice,
		&i.Warehouse,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ID_2,
		&i.Code_2,
		&i.Name,
		&i.DeputyName,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.Company,
		&i.ID_3,
		&i.FullName,
		&i.Code_3,
		&i.Company_2,
		&i.Address_2,
		&i.Email_2,
		&i.Phone_2,
		&i.License,
		&i.Birthday,
		&i.UserCreated_2,
		&i.UserUpdated_2,
		&i.UpdatedAt_2,
		&i.CreatedAt_2,
		&i.ID_4,
		&i.Address_3,
		&i.Companies,
		&i.Name_2,
		&i.Code_4,
		&i.ID_5,
		&i.Code_5,
		&i.Title,
		&i.ID_6,
		&i.Code_6,
		&i.Title_2,
		&i.ID_7,
		&i.MediaUrl,
		&i.ID_8,
		&i.Username,
		&i.HashedPassword,
		&i.FullName_2,
		&i.Email_3,
		&i.Type_2,
		&i.IsVerify,
		&i.PasswordChangedAt,
		&i.CreatedAt_3,
		&i.Role,
		&i.Gender,
		&i.Licence,
		&i.Dob,
		&i.Address_4,
		&i.ID_9,
		&i.Username_2,
		&i.HashedPassword_2,
		&i.FullName_3,
		&i.Email_4,
		&i.Type_3,
		&i.IsVerify_2,
		&i.PasswordChangedAt_2,
		&i.CreatedAt_4,
		&i.Role_2,
		&i.Gender_2,
		&i.Licence_2,
		&i.Dob_2,
		&i.Address_5,
		&i.QrUrl,
		&i.UserCreatedName,
		&i.UserUpdatedName,
		&i.WID,
		&i.WName,
		&i.WCode,
		&i.WAddress,
		&i.CID,
		&i.CName,
		&i.CCode,
		&i.CAddress,
		&i.CEmail,
		&i.CPhone,
		&i.CCompany,
		&i.SID,
		&i.SCode,
		&i.SName,
		&i.SDeputy,
		&i.SPhone,
		&i.SEmail,
		&i.SAddress,
		&i.SCompany,
		&i.TtID,
		&i.TtCode,
		&i.TtTitle,
		&i.TsID,
		&i.TsCode,
		&i.TsTitle,
	)
	return i, err
}

const getItemsTicket = `-- name: GetItemsTicket :many
SELECT id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant FROM consignment
WHERE ticket = $1
`

func (q *Queries) GetItemsTicket(ctx context.Context, ticket sql.NullInt32) ([]Consignment, error) {
	rows, err := q.db.QueryContext(ctx, getItemsTicket, ticket)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Consignment{}
	for rows.Next() {
		var i Consignment
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Variant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTicket = `-- name: GetListTicket :many
SELECT t.id, t.code, t.type, status, note, qr, export_to, import_from, total_price, warehouse, t.user_created, t.user_updated, t.updated_at, t.created_at, w.id, w.address, companies, w.name, w.code, a.id, username, hashed_password, full_name, a.email, a.type, is_verify, password_changed_at, a.created_at, role, gender, licence, dob, a.address, m.id, media_url, tt.id, tt.code, tt.title, ts.id, ts.code, ts.title, c.id, c.code, quantity, inventory, ticket, expired_at, producted_at, is_available, c.user_created, c.user_updated, c.updated_at, c.created_at, variant, s.id, s.code, s.name, deputy_name, phone, s.email, s.address, company, w.name AS w_name, a.full_name AS a_full_name, m.media_url AS qr_url,
    tt.id AS tt_id, tt.code AS tt_code, tt.title AS tt_title,
    ts.id AS ts_id, ts.code AS ts_code, ts.title AS ts_title,
    COALESCE(SUM(c.quantity), 0)::int AS total_products
FROM tickets t
JOIN warehouses w ON t.warehouse = w.id
JOIN accounts a ON t.user_created = a.id
JOIN medias m ON t.qr = m.id
JOIN ticket_type tt ON t.type = tt.id
JOIN ticket_status ts ON t.status = ts.id
LEFT JOIN consignment c ON t.id = c.ticket
LEFT JOIN suplier s ON s.address = t.import_from
WHERE w.companies = $1
AND (
    $2::varchar IS NULL OR ts.code = $2::varchar
)
AND (
    $3::varchar IS NULL OR tt.code = $3::varchar
)
AND (
    $4::int IS NULL OR s.id = $4::int
)
AND (
    t.code ILIKE '%' || COALESCE($5::varchar, '') || '%'
)
GROUP BY
    t.id, t.code, t.type, t.status, t.note, t.qr, t.total_price, t.warehouse, t.user_created, t.created_at,
    w.id, a.id, m.id, tt.id, ts.id, c.ticket, c.id,
    w.name, a.full_name, m.media_url, tt.id, tt.code, tt.title, ts.id, ts.code, ts.title,
    s.id
ORDER BY -t.id
LIMIT COALESCE($7::int, 10)
OFFSET (COALESCE($6::int, 1) - 1) * COALESCE($7::int, 10)
`

type GetListTicketParams struct {
	Company  sql.NullInt32  `json:"company"`
	Status   sql.NullString `json:"status"`
	Type     sql.NullString `json:"type"`
	Supplier sql.NullInt32  `json:"supplier"`
	Search   sql.NullString `json:"search"`
	Page     sql.NullInt32  `json:"page"`
	Limit    sql.NullInt32  `json:"limit"`
}

type GetListTicketRow struct {
	ID                int32          `json:"id"`
	Code              string         `json:"code"`
	Type              sql.NullInt32  `json:"type"`
	Status            sql.NullInt32  `json:"status"`
	Note              sql.NullString `json:"note"`
	Qr                sql.NullInt32  `json:"qr"`
	ExportTo          sql.NullInt32  `json:"export_to"`
	ImportFrom        sql.NullInt32  `json:"import_from"`
	TotalPrice        float64        `json:"total_price"`
	Warehouse         int32          `json:"warehouse"`
	UserCreated       int32          `json:"user_created"`
	UserUpdated       sql.NullInt32  `json:"user_updated"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	CreatedAt         time.Time      `json:"created_at"`
	ID_2              int32          `json:"id_2"`
	Address           sql.NullInt32  `json:"address"`
	Companies         sql.NullInt32  `json:"companies"`
	Name              string         `json:"name"`
	Code_2            string         `json:"code_2"`
	ID_3              int32          `json:"id_3"`
	Username          string         `json:"username"`
	HashedPassword    string         `json:"hashed_password"`
	FullName          string         `json:"full_name"`
	Email             string         `json:"email"`
	Type_2            int32          `json:"type_2"`
	IsVerify          bool           `json:"is_verify"`
	PasswordChangedAt time.Time      `json:"password_changed_at"`
	CreatedAt_2       time.Time      `json:"created_at_2"`
	Role              sql.NullInt32  `json:"role"`
	Gender            NullGender     `json:"gender"`
	Licence           sql.NullString `json:"licence"`
	Dob               sql.NullTime   `json:"dob"`
	Address_2         sql.NullInt32  `json:"address_2"`
	ID_4              int32          `json:"id_4"`
	MediaUrl          string         `json:"media_url"`
	ID_5              int32          `json:"id_5"`
	Code_3            string         `json:"code_3"`
	Title             string         `json:"title"`
	ID_6              int32          `json:"id_6"`
	Code_4            string         `json:"code_4"`
	Title_2           string         `json:"title_2"`
	ID_7              sql.NullInt32  `json:"id_7"`
	Code_5            sql.NullString `json:"code_5"`
	Quantity          sql.NullInt32  `json:"quantity"`
	Inventory         sql.NullInt32  `json:"inventory"`
	Ticket            sql.NullInt32  `json:"ticket"`
	ExpiredAt         sql.NullTime   `json:"expired_at"`
	ProductedAt       sql.NullTime   `json:"producted_at"`
	IsAvailable       sql.NullBool   `json:"is_available"`
	UserCreated_2     sql.NullInt32  `json:"user_created_2"`
	UserUpdated_2     sql.NullInt32  `json:"user_updated_2"`
	UpdatedAt_2       sql.NullTime   `json:"updated_at_2"`
	CreatedAt_3       sql.NullTime   `json:"created_at_3"`
	Variant           sql.NullInt32  `json:"variant"`
	ID_8              sql.NullInt32  `json:"id_8"`
	Code_6            sql.NullString `json:"code_6"`
	Name_2            sql.NullString `json:"name_2"`
	DeputyName        sql.NullString `json:"deputy_name"`
	Phone             sql.NullString `json:"phone"`
	Email_2           sql.NullString `json:"email_2"`
	Address_3         sql.NullInt32  `json:"address_3"`
	Company           sql.NullInt32  `json:"company"`
	WName             string         `json:"w_name"`
	AFullName         string         `json:"a_full_name"`
	QrUrl             string         `json:"qr_url"`
	TtID              int32          `json:"tt_id"`
	TtCode            string         `json:"tt_code"`
	TtTitle           string         `json:"tt_title"`
	TsID              int32          `json:"ts_id"`
	TsCode            string         `json:"ts_code"`
	TsTitle           string         `json:"ts_title"`
	TotalProducts     int32          `json:"total_products"`
}

func (q *Queries) GetListTicket(ctx context.Context, arg GetListTicketParams) ([]GetListTicketRow, error) {
	rows, err := q.db.QueryContext(ctx, getListTicket,
		arg.Company,
		arg.Status,
		arg.Type,
		arg.Supplier,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListTicketRow{}
	for rows.Next() {
		var i GetListTicketRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.Status,
			&i.Note,
			&i.Qr,
			&i.ExportTo,
			&i.ImportFrom,
			&i.TotalPrice,
			&i.Warehouse,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ID_2,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code_2,
			&i.ID_3,
			&i.Username,
			&i.HashedPassword,
			&i.FullName,
			&i.Email,
			&i.Type_2,
			&i.IsVerify,
			&i.PasswordChangedAt,
			&i.CreatedAt_2,
			&i.Role,
			&i.Gender,
			&i.Licence,
			&i.Dob,
			&i.Address_2,
			&i.ID_4,
			&i.MediaUrl,
			&i.ID_5,
			&i.Code_3,
			&i.Title,
			&i.ID_6,
			&i.Code_4,
			&i.Title_2,
			&i.ID_7,
			&i.Code_5,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated_2,
			&i.UserUpdated_2,
			&i.UpdatedAt_2,
			&i.CreatedAt_3,
			&i.Variant,
			&i.ID_8,
			&i.Code_6,
			&i.Name_2,
			&i.DeputyName,
			&i.Phone,
			&i.Email_2,
			&i.Address_3,
			&i.Company,
			&i.WName,
			&i.AFullName,
			&i.QrUrl,
			&i.TtID,
			&i.TtCode,
			&i.TtTitle,
			&i.TsID,
			&i.TsCode,
			&i.TsTitle,
			&i.TotalProducts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketStatus = `-- name: GetTicketStatus :one
SELECT id, code, title FROM ticket_status
WHERE id = $1 OR code = $2
`

type GetTicketStatusParams struct {
	ID   sql.NullInt32  `json:"id"`
	Code sql.NullString `json:"code"`
}

func (q *Queries) GetTicketStatus(ctx context.Context, arg GetTicketStatusParams) (TicketStatus, error) {
	row := q.db.QueryRowContext(ctx, getTicketStatus, arg.ID, arg.Code)
	var i TicketStatus
	err := row.Scan(&i.ID, &i.Code, &i.Title)
	return i, err
}

const getTicketType = `-- name: GetTicketType :one
SELECT id, code, title FROM ticket_type
WHERE id = $1 OR code = $2
`

type GetTicketTypeParams struct {
	ID   sql.NullInt32  `json:"id"`
	Code sql.NullString `json:"code"`
}

func (q *Queries) GetTicketType(ctx context.Context, arg GetTicketTypeParams) (TicketType, error) {
	row := q.db.QueryRowContext(ctx, getTicketType, arg.ID, arg.Code)
	var i TicketType
	err := row.Scan(&i.ID, &i.Code, &i.Title)
	return i, err
}

const getWarehouse = `-- name: GetWarehouse :one
SELECT id, address, companies, name, code FROM warehouses
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetWarehouse(ctx context.Context, id int32) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, getWarehouse, id)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const listWarehouse = `-- name: ListWarehouse :many
SELECT id, address, companies, name, code FROM warehouses
WHERE companies = $1::int AND (
    name ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    code ILIKE '%' || COALESCE($2::varchar, '') || '%'
)
ORDER BY -id
LIMIT COALESCE($4::int, 10)
OFFSET (COALESCE($3::int, 1) - 1) * COALESCE($4::int, 10)
`

type ListWarehouseParams struct {
	Company sql.NullInt32  `json:"company"`
	Search  sql.NullString `json:"search"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

func (q *Queries) ListWarehouse(ctx context.Context, arg ListWarehouseParams) ([]Warehouse, error) {
	rows, err := q.db.QueryContext(ctx, listWarehouse,
		arg.Company,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Warehouse{}
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const suggestConsignmentForVariant = `-- name: SuggestConsignmentForVariant :one
SELECT id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant FROM consignment c
WHERE c.variant = $1
AND is_available = true
AND inventory > $2
ORDER BY ABS(EXTRACT(EPOCH FROM (expired_at - NOW()))) ASC
LIMIT 1
`

type SuggestConsignmentForVariantParams struct {
	Variant   sql.NullInt32 `json:"variant"`
	Inventory int32         `json:"inventory"`
}

func (q *Queries) SuggestConsignmentForVariant(ctx context.Context, arg SuggestConsignmentForVariantParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, suggestConsignmentForVariant, arg.Variant, arg.Inventory)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const updateConsignment = `-- name: UpdateConsignment :one
UPDATE consignment
SET inventory = inventory + $1::int
WHERE id = $2
RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

type UpdateConsignmentParams struct {
	Amount int32 `json:"amount"`
	ID     int32 `json:"id"`
}

func (q *Queries) UpdateConsignment(ctx context.Context, arg UpdateConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, updateConsignment, arg.Amount, arg.ID)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const updateConsignmentByTicket = `-- name: UpdateConsignmentByTicket :many
UPDATE consignment
SET is_available = true
WHERE ticket = $1
RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

func (q *Queries) UpdateConsignmentByTicket(ctx context.Context, ticket sql.NullInt32) ([]Consignment, error) {
	rows, err := q.db.QueryContext(ctx, updateConsignmentByTicket, ticket)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Consignment{}
	for rows.Next() {
		var i Consignment
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Variant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE tickets
SET status = $1
WHERE id = $2
RETURNING id, code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated, updated_at, created_at
`

type UpdateTicketStatusParams struct {
	Status sql.NullInt32 `json:"status"`
	ID     int32         `json:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.Status, arg.ID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Note,
		&i.Qr,
		&i.ExportTo,
		&i.ImportFrom,
		&i.TotalPrice,
		&i.Warehouse,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateWarehouse = `-- name: UpdateWarehouse :one
UPDATE warehouses
SET
    name = COALESCE($2, name),
    code = COALESCE($3, code)
WHERE id = $1 RETURNING id, address, companies, name, code
`

type UpdateWarehouseParams struct {
	ID   int32          `json:"id"`
	Name sql.NullString `json:"name"`
	Code sql.NullString `json:"code"`
}

func (q *Queries) UpdateWarehouse(ctx context.Context, arg UpdateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, updateWarehouse, arg.ID, arg.Name, arg.Code)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}
