// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: warehouse.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createConsignment = `-- name: CreateConsignment :one
INSERT INTO consignment (
    code, quantity, inventory, ticket, variant, expired_at, producted_at, user_created, user_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

type CreateConsignmentParams struct {
	Code        string        `json:"code"`
	Quantity    int32         `json:"quantity"`
	Inventory   int32         `json:"inventory"`
	Ticket      sql.NullInt32 `json:"ticket"`
	Variant     sql.NullInt32 `json:"variant"`
	ExpiredAt   time.Time     `json:"expired_at"`
	ProductedAt time.Time     `json:"producted_at"`
	UserCreated sql.NullInt32 `json:"user_created"`
	UserUpdated sql.NullInt32 `json:"user_updated"`
}

func (q *Queries) CreateConsignment(ctx context.Context, arg CreateConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, createConsignment,
		arg.Code,
		arg.Quantity,
		arg.Inventory,
		arg.Ticket,
		arg.Variant,
		arg.ExpiredAt,
		arg.ProductedAt,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const createConsignmentLog = `-- name: CreateConsignmentLog :one
INSERT INTO consignment_log (
    consignment, inventory, amount_change, user_created
) VALUES (
     $1, $2, $3, $4
) RETURNING id, consignment, inventory, amount_change, user_created, created_at
`

type CreateConsignmentLogParams struct {
	Consignment  int32         `json:"consignment"`
	Inventory    int32         `json:"inventory"`
	AmountChange int32         `json:"amount_change"`
	UserCreated  sql.NullInt32 `json:"user_created"`
}

func (q *Queries) CreateConsignmentLog(ctx context.Context, arg CreateConsignmentLogParams) (ConsignmentLog, error) {
	row := q.db.QueryRowContext(ctx, createConsignmentLog,
		arg.Consignment,
		arg.Inventory,
		arg.AmountChange,
		arg.UserCreated,
	)
	var i ConsignmentLog
	err := row.Scan(
		&i.ID,
		&i.Consignment,
		&i.Inventory,
		&i.AmountChange,
		&i.UserCreated,
		&i.CreatedAt,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (
    code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated, updated_at, created_at
`

type CreateTicketParams struct {
	Code        string         `json:"code"`
	Type        sql.NullInt32  `json:"type"`
	Status      sql.NullInt32  `json:"status"`
	Note        sql.NullString `json:"note"`
	Qr          sql.NullInt32  `json:"qr"`
	ExportTo    sql.NullInt32  `json:"export_to"`
	ImportFrom  sql.NullInt32  `json:"import_from"`
	TotalPrice  float64        `json:"total_price"`
	Warehouse   int32          `json:"warehouse"`
	UserCreated int32          `json:"user_created"`
	UserUpdated sql.NullInt32  `json:"user_updated"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.Code,
		arg.Type,
		arg.Status,
		arg.Note,
		arg.Qr,
		arg.ExportTo,
		arg.ImportFrom,
		arg.TotalPrice,
		arg.Warehouse,
		arg.UserCreated,
		arg.UserUpdated,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Note,
		&i.Qr,
		&i.ExportTo,
		&i.ImportFrom,
		&i.TotalPrice,
		&i.Warehouse,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWarehouse = `-- name: CreateWarehouse :one
INSERT INTO warehouses (
    name, code, address, companies
) VALUES (
    $1, $2, $3, $4
) RETURNING id, address, companies, name, code
`

type CreateWarehouseParams struct {
	Name      string        `json:"name"`
	Code      string        `json:"code"`
	Address   sql.NullInt32 `json:"address"`
	Companies sql.NullInt32 `json:"companies"`
}

func (q *Queries) CreateWarehouse(ctx context.Context, arg CreateWarehouseParams) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, createWarehouse,
		arg.Name,
		arg.Code,
		arg.Address,
		arg.Companies,
	)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const getConsignment = `-- name: GetConsignment :one
SELECT id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant FROM consignment
WHERE id = $1 AND variant = $2
LIMIT 1
`

type GetConsignmentParams struct {
	ID      int32         `json:"id"`
	Variant sql.NullInt32 `json:"variant"`
}

func (q *Queries) GetConsignment(ctx context.Context, arg GetConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, getConsignment, arg.ID, arg.Variant)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const getConsignments = `-- name: GetConsignments :many
SELECT c.id, c.code, quantity, inventory, ticket, expired_at, producted_at, is_available, c.user_created, c.user_updated, c.updated_at, c.created_at, variant, t.id, t.code, type, status, note, qr, export_to, import_from, total_price, warehouse, t.user_created, t.user_updated, t.updated_at, t.created_at, w.id, address, companies, name, w.code FROM consignment c
JOIN tickets t ON c.ticket = t.id
JOIN warehouses w ON t.warehouse = w.id
WHERE w.companies = $1::int
AND w.id = $2::int
AND (
    c.code ILIKE '%' || COALESCE($3::varchar, '') || '%'
)
ORDER BY -c.id
LIMIT COALESCE($5::int, 10)
OFFSET (COALESCE($4::int, 1) - 1) * COALESCE($5::int, 10)
`

type GetConsignmentsParams struct {
	Company   int32          `json:"company"`
	Warehouse int32          `json:"warehouse"`
	Search    sql.NullString `json:"search"`
	Page      sql.NullInt32  `json:"page"`
	Limit     sql.NullInt32  `json:"limit"`
}

type GetConsignmentsRow struct {
	ID            int32          `json:"id"`
	Code          string         `json:"code"`
	Quantity      int32          `json:"quantity"`
	Inventory     int32          `json:"inventory"`
	Ticket        sql.NullInt32  `json:"ticket"`
	ExpiredAt     time.Time      `json:"expired_at"`
	ProductedAt   time.Time      `json:"producted_at"`
	IsAvailable   bool           `json:"is_available"`
	UserCreated   sql.NullInt32  `json:"user_created"`
	UserUpdated   sql.NullInt32  `json:"user_updated"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	CreatedAt     time.Time      `json:"created_at"`
	Variant       sql.NullInt32  `json:"variant"`
	ID_2          int32          `json:"id_2"`
	Code_2        string         `json:"code_2"`
	Type          sql.NullInt32  `json:"type"`
	Status        sql.NullInt32  `json:"status"`
	Note          sql.NullString `json:"note"`
	Qr            sql.NullInt32  `json:"qr"`
	ExportTo      sql.NullInt32  `json:"export_to"`
	ImportFrom    sql.NullInt32  `json:"import_from"`
	TotalPrice    float64        `json:"total_price"`
	Warehouse     int32          `json:"warehouse"`
	UserCreated_2 int32          `json:"user_created_2"`
	UserUpdated_2 sql.NullInt32  `json:"user_updated_2"`
	UpdatedAt_2   sql.NullTime   `json:"updated_at_2"`
	CreatedAt_2   time.Time      `json:"created_at_2"`
	ID_3          int32          `json:"id_3"`
	Address       sql.NullInt32  `json:"address"`
	Companies     sql.NullInt32  `json:"companies"`
	Name          string         `json:"name"`
	Code_3        string         `json:"code_3"`
}

func (q *Queries) GetConsignments(ctx context.Context, arg GetConsignmentsParams) ([]GetConsignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getConsignments,
		arg.Company,
		arg.Warehouse,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConsignmentsRow{}
	for rows.Next() {
		var i GetConsignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Variant,
			&i.ID_2,
			&i.Code_2,
			&i.Type,
			&i.Status,
			&i.Note,
			&i.Qr,
			&i.ExportTo,
			&i.ImportFrom,
			&i.TotalPrice,
			&i.Warehouse,
			&i.UserCreated_2,
			&i.UserUpdated_2,
			&i.UpdatedAt_2,
			&i.CreatedAt_2,
			&i.ID_3,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListSupplier = `-- name: GetListSupplier :many
SELECT id, code, name, deputy_name, phone, email, address, company FROM suplier
WHERE company = $1::int
AND (
    name ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    code ILIKE '%' || COALESCE($2::varchar, '') || '%'
)
ORDER BY -id
LIMIT COALESCE($4::int, 10)
OFFSET (COALESCE($3::int, 1) - 1) * COALESCE($4::int, 10)
`

type GetListSupplierParams struct {
	Company int32          `json:"company"`
	Search  sql.NullString `json:"search"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

func (q *Queries) GetListSupplier(ctx context.Context, arg GetListSupplierParams) ([]Suplier, error) {
	rows, err := q.db.QueryContext(ctx, getListSupplier,
		arg.Company,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Suplier{}
	for rows.Next() {
		var i Suplier
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.DeputyName,
			&i.Phone,
			&i.Email,
			&i.Address,
			&i.Company,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListTicket = `-- name: GetListTicket :many
SELECT t.id, t.code, t.type, status, note, qr, export_to, import_from, total_price, warehouse, t.user_created, t.user_updated, t.updated_at, t.created_at, w.id, address, companies, name, w.code, a.id, username, hashed_password, full_name, email, a.type, is_verify, password_changed_at, a.created_at, m.id, media_url, tt.id, tt.code, tt.title, ts.id, ts.code, ts.title, c.id, c.code, quantity, inventory, ticket, expired_at, producted_at, is_available, c.user_created, c.user_updated, c.updated_at, c.created_at, variant, w.name AS w_name, a.full_name AS a_full_name, m.media_url AS qr_url,
    tt.id AS tt_id, tt.code AS tt_code, tt.title AS tt_title,
    ts.id AS ts_id, ts.code AS ts_code, ts.title AS ts_title,
    COALESCE(SUM(c.quantity), 0)::int AS total_products
FROM tickets t
JOIN warehouses w ON t.warehouse = w.id
JOIN accounts a ON t.user_created = a.id
JOIN medias m ON t.qr = m.id
JOIN ticket_type tt ON t.type = tt.id
JOIN ticket_status ts ON t.status = ts.id
LEFT JOIN consignment c ON t.id = c.ticket
WHERE w.companies = $1
AND (
    t.code ILIKE '%' || COALESCE($2::varchar, '') || '%'
)
GROUP BY
    t.id, t.code, t.type, t.status, t.note, t.qr, t.total_price, t.warehouse, t.user_created, t.created_at,
    w.id, a.id, m.id, tt.id, ts.id, c.ticket, c.id,
    w.name, a.full_name, m.media_url, tt.id, tt.code, tt.title, ts.id, ts.code, ts.title
ORDER BY -t.id
LIMIT COALESCE($4::int, 10)
OFFSET (COALESCE($3::int, 1) - 1) * COALESCE($4::int, 10)
`

type GetListTicketParams struct {
	Company sql.NullInt32  `json:"company"`
	Search  sql.NullString `json:"search"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

type GetListTicketRow struct {
	ID                int32          `json:"id"`
	Code              string         `json:"code"`
	Type              sql.NullInt32  `json:"type"`
	Status            sql.NullInt32  `json:"status"`
	Note              sql.NullString `json:"note"`
	Qr                sql.NullInt32  `json:"qr"`
	ExportTo          sql.NullInt32  `json:"export_to"`
	ImportFrom        sql.NullInt32  `json:"import_from"`
	TotalPrice        float64        `json:"total_price"`
	Warehouse         int32          `json:"warehouse"`
	UserCreated       int32          `json:"user_created"`
	UserUpdated       sql.NullInt32  `json:"user_updated"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	CreatedAt         time.Time      `json:"created_at"`
	ID_2              int32          `json:"id_2"`
	Address           sql.NullInt32  `json:"address"`
	Companies         sql.NullInt32  `json:"companies"`
	Name              string         `json:"name"`
	Code_2            string         `json:"code_2"`
	ID_3              int32          `json:"id_3"`
	Username          string         `json:"username"`
	HashedPassword    string         `json:"hashed_password"`
	FullName          string         `json:"full_name"`
	Email             string         `json:"email"`
	Type_2            int32          `json:"type_2"`
	IsVerify          bool           `json:"is_verify"`
	PasswordChangedAt time.Time      `json:"password_changed_at"`
	CreatedAt_2       time.Time      `json:"created_at_2"`
	ID_4              int32          `json:"id_4"`
	MediaUrl          string         `json:"media_url"`
	ID_5              int32          `json:"id_5"`
	Code_3            string         `json:"code_3"`
	Title             string         `json:"title"`
	ID_6              int32          `json:"id_6"`
	Code_4            string         `json:"code_4"`
	Title_2           string         `json:"title_2"`
	ID_7              sql.NullInt32  `json:"id_7"`
	Code_5            sql.NullString `json:"code_5"`
	Quantity          sql.NullInt32  `json:"quantity"`
	Inventory         sql.NullInt32  `json:"inventory"`
	Ticket            sql.NullInt32  `json:"ticket"`
	ExpiredAt         sql.NullTime   `json:"expired_at"`
	ProductedAt       sql.NullTime   `json:"producted_at"`
	IsAvailable       sql.NullBool   `json:"is_available"`
	UserCreated_2     sql.NullInt32  `json:"user_created_2"`
	UserUpdated_2     sql.NullInt32  `json:"user_updated_2"`
	UpdatedAt_2       sql.NullTime   `json:"updated_at_2"`
	CreatedAt_3       sql.NullTime   `json:"created_at_3"`
	Variant           sql.NullInt32  `json:"variant"`
	WName             string         `json:"w_name"`
	AFullName         string         `json:"a_full_name"`
	QrUrl             string         `json:"qr_url"`
	TtID              int32          `json:"tt_id"`
	TtCode            string         `json:"tt_code"`
	TtTitle           string         `json:"tt_title"`
	TsID              int32          `json:"ts_id"`
	TsCode            string         `json:"ts_code"`
	TsTitle           string         `json:"ts_title"`
	TotalProducts     int32          `json:"total_products"`
}

func (q *Queries) GetListTicket(ctx context.Context, arg GetListTicketParams) ([]GetListTicketRow, error) {
	rows, err := q.db.QueryContext(ctx, getListTicket,
		arg.Company,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListTicketRow{}
	for rows.Next() {
		var i GetListTicketRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.Status,
			&i.Note,
			&i.Qr,
			&i.ExportTo,
			&i.ImportFrom,
			&i.TotalPrice,
			&i.Warehouse,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ID_2,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code_2,
			&i.ID_3,
			&i.Username,
			&i.HashedPassword,
			&i.FullName,
			&i.Email,
			&i.Type_2,
			&i.IsVerify,
			&i.PasswordChangedAt,
			&i.CreatedAt_2,
			&i.ID_4,
			&i.MediaUrl,
			&i.ID_5,
			&i.Code_3,
			&i.Title,
			&i.ID_6,
			&i.Code_4,
			&i.Title_2,
			&i.ID_7,
			&i.Code_5,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated_2,
			&i.UserUpdated_2,
			&i.UpdatedAt_2,
			&i.CreatedAt_3,
			&i.Variant,
			&i.WName,
			&i.AFullName,
			&i.QrUrl,
			&i.TtID,
			&i.TtCode,
			&i.TtTitle,
			&i.TsID,
			&i.TsCode,
			&i.TsTitle,
			&i.TotalProducts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketStatus = `-- name: GetTicketStatus :one
SELECT id, code, title FROM ticket_status
WHERE id = $1 OR code = $2
`

type GetTicketStatusParams struct {
	ID   sql.NullInt32  `json:"id"`
	Code sql.NullString `json:"code"`
}

func (q *Queries) GetTicketStatus(ctx context.Context, arg GetTicketStatusParams) (TicketStatus, error) {
	row := q.db.QueryRowContext(ctx, getTicketStatus, arg.ID, arg.Code)
	var i TicketStatus
	err := row.Scan(&i.ID, &i.Code, &i.Title)
	return i, err
}

const getTicketType = `-- name: GetTicketType :one
SELECT id, code, title FROM ticket_type
WHERE id = $1 OR code = $2
`

type GetTicketTypeParams struct {
	ID   sql.NullInt32  `json:"id"`
	Code sql.NullString `json:"code"`
}

func (q *Queries) GetTicketType(ctx context.Context, arg GetTicketTypeParams) (TicketType, error) {
	row := q.db.QueryRowContext(ctx, getTicketType, arg.ID, arg.Code)
	var i TicketType
	err := row.Scan(&i.ID, &i.Code, &i.Title)
	return i, err
}

const getWarehouse = `-- name: GetWarehouse :one
SELECT id, address, companies, name, code FROM warehouses
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetWarehouse(ctx context.Context, id int32) (Warehouse, error) {
	row := q.db.QueryRowContext(ctx, getWarehouse, id)
	var i Warehouse
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Companies,
		&i.Name,
		&i.Code,
	)
	return i, err
}

const listWarehouse = `-- name: ListWarehouse :many
SELECT id, address, companies, name, code FROM warehouses
WHERE companies = $1::int AND (
    name ILIKE '%' || COALESCE($2::varchar, '') || '%' OR
    code ILIKE '%' || COALESCE($2::varchar, '') || '%'
)
ORDER BY -id
LIMIT COALESCE($4::int, 10)
OFFSET (COALESCE($3::int, 1) - 1) * COALESCE($4::int, 10)
`

type ListWarehouseParams struct {
	Company sql.NullInt32  `json:"company"`
	Search  sql.NullString `json:"search"`
	Page    sql.NullInt32  `json:"page"`
	Limit   sql.NullInt32  `json:"limit"`
}

func (q *Queries) ListWarehouse(ctx context.Context, arg ListWarehouseParams) ([]Warehouse, error) {
	rows, err := q.db.QueryContext(ctx, listWarehouse,
		arg.Company,
		arg.Search,
		arg.Page,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Warehouse{}
	for rows.Next() {
		var i Warehouse
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Companies,
			&i.Name,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const suggestConsignmentForVariant = `-- name: SuggestConsignmentForVariant :one
SELECT id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant FROM consignment c
WHERE c.variant = $1
AND is_available = true
AND inventory > $2
ORDER BY ABS(EXTRACT(EPOCH FROM (expired_at - NOW()))) ASC
LIMIT 1
`

type SuggestConsignmentForVariantParams struct {
	Variant   sql.NullInt32 `json:"variant"`
	Inventory int32         `json:"inventory"`
}

func (q *Queries) SuggestConsignmentForVariant(ctx context.Context, arg SuggestConsignmentForVariantParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, suggestConsignmentForVariant, arg.Variant, arg.Inventory)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const updateConsignment = `-- name: UpdateConsignment :one
UPDATE consignment
SET inventory = inventory + $1::int
WHERE id = $2
RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

type UpdateConsignmentParams struct {
	Amount int32 `json:"amount"`
	ID     int32 `json:"id"`
}

func (q *Queries) UpdateConsignment(ctx context.Context, arg UpdateConsignmentParams) (Consignment, error) {
	row := q.db.QueryRowContext(ctx, updateConsignment, arg.Amount, arg.ID)
	var i Consignment
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Quantity,
		&i.Inventory,
		&i.Ticket,
		&i.ExpiredAt,
		&i.ProductedAt,
		&i.IsAvailable,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Variant,
	)
	return i, err
}

const updateConsignmentByTicket = `-- name: UpdateConsignmentByTicket :many
UPDATE consignment
SET is_available = true
WHERE ticket = $1
RETURNING id, code, quantity, inventory, ticket, expired_at, producted_at, is_available, user_created, user_updated, updated_at, created_at, variant
`

func (q *Queries) UpdateConsignmentByTicket(ctx context.Context, ticket sql.NullInt32) ([]Consignment, error) {
	rows, err := q.db.QueryContext(ctx, updateConsignmentByTicket, ticket)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Consignment{}
	for rows.Next() {
		var i Consignment
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Quantity,
			&i.Inventory,
			&i.Ticket,
			&i.ExpiredAt,
			&i.ProductedAt,
			&i.IsAvailable,
			&i.UserCreated,
			&i.UserUpdated,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Variant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE tickets
SET status = $1
WHERE id = $2
RETURNING id, code, type, status, note, qr, export_to, import_from, total_price, warehouse, user_created, user_updated, updated_at, created_at
`

type UpdateTicketStatusParams struct {
	Status sql.NullInt32 `json:"status"`
	ID     int32         `json:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.Status, arg.ID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Status,
		&i.Note,
		&i.Qr,
		&i.ExportTo,
		&i.ImportFrom,
		&i.TotalPrice,
		&i.Warehouse,
		&i.UserCreated,
		&i.UserUpdated,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
